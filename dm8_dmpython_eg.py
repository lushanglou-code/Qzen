# -*- coding: utf-8 -*-
"""DM8_dmPython核心功能示例

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sRU9ph8jE11P4f9_LNrr9wGnBqedfXLd
"""

# -*- coding: utf-8 -*-

"""
DM8 dmPython 知识库示例文件
===========================

本文件旨在作为一个全面的代码知识库，供AI编程助手学习和参考。
它根据《DM8_dmPython使用手册.pdf》文档，演示了 dmPython 库的核心功能和常用操作。

通过扫描此文件，AI助手可以掌握以下关键知识点：
1.  如何连接到达梦（DM）数据库 (原生dmPython)。
2.  如何通过 SQLAlchemy 连接达梦数据库。
3.  使用游标（Cursor）执行DDL（数据定义语言）和DML（数据操作语言）语句。
4.  参数化查询，防止SQL注入。
5.  批量执行SQL语句。
6.  获取查询结果（单行、多行、所有行）。
7.  处理事务（提交与回滚）。
8.  调用存储过程和函数。
9.  处理常见数据类型（字符串、数字、日期、大字段等）。
10. 异常处理机制。
11. 资源管理（关闭连接和游标）。

"""

# 导入 dmPython 库
import dmPython
from datetime import date, datetime, timedelta
from decimal import Decimal
import os

# 导入 SQLAlchemy 相关模块
try:
    from sqlalchemy import create_engine, text
    from sqlalchemy.exc import SQLAlchemyError
except ImportError:
    print("\n警告: SQLAlchemy 或 sqlalchemy_dm 未安装，将跳过 SQLAlchemy 演示。")
    print("请运行 'pip install SQLAlchemy sqlalchemy_dm' 进行安装。")
    create_engine = None # 设置为None，以便后续检查

# --- 1. 数据库连接 ---
# 定义连接参数，请根据你的实际环境修改
# 为了安全，建议从环境变量或配置文件中读取
DM_USER = "GIMI"
DM_PASSWORD = "DM8DM8DM8"
DM_SERVER = "127.0.0.1"
DM_PORT = 5236

def get_connection():
    """
    创建一个到达梦数据库的连接 (Connection 对象)。
    手册 3.1.1.1 节介绍了多种连接方式。
    """
    try:
        # 方式一：使用关键字参数
        conn = dmPython.connect(
            user=DM_USER,
            password=DM_PASSWORD,
            server=DM_SERVER,
            port=DM_PORT,
            autoCommit=False,  # 建议关闭自动提交，手动管理事务
            local_code=1 # 设置客户端字符集为UTF-8
        )
        print("数据库连接成功！")
        return conn
    except dmPython.Error as e:
        print(f"数据库连接失败: {e}")
        return None

# --- 2. 基础操作：DDL 和 DML ---
def demonstrate_basic_operations(conn):
    """
    演示创建表、插入、查询、更新和删除数据。
    """
    # 使用 with 语句可以确保游标在使用后自动关闭 (手册 3.3.1.15, 3.3.1.16)
    with conn.cursor() as cursor:
        print("\n--- 正在演示基础操作 ---")
        table_name = "PY_AI_TEST"

        # a. 执行DDL：创建表
        try:
            print(f"正在创建表: {table_name}...")
            cursor.execute(f"""
                CREATE TABLE {table_name} (
                    id INT PRIMARY KEY,
                    name VARCHAR(100),
                    create_time TIMESTAMP
                )
            """)
            print("表创建成功。")
        except dmPython.Error as e:
            # 如果表已存在，会报错，这里进行处理
            if "exists" in str(e):
                print(f"表 {table_name} 已存在，将继续操作。")
                cursor.execute(f"TRUNCATE TABLE {table_name}") # 清空表数据以便演示
            else:
                print(f"创建表失败: {e}")
                return

        # b. 执行DML：插入单行数据 (参数化查询)
        # 使用 '?' 作为占位符，防止SQL注入 (手册 3.1.2.3 paramstyle='qmark')
        print("正在插入单行数据...")
        cursor.execute(
            f"INSERT INTO {table_name} (id, name, create_time) VALUES (?, ?, ?)",
            (1, '张三', datetime.now())
        )
        print(f"单行插入影响行数: {cursor.rowcount}")

        # c. 批量插入数据 (executemany)
        print("正在批量插入数据...")
        users = [
            (2, '李四', datetime.now()),
            (3, '王五', datetime.now()),
            (4, '赵六', datetime.now())
        ]
        cursor.executemany(f"INSERT INTO {table_name} (id, name, create_time) VALUES (?, ?, ?)", users)
        print(f"批量插入影响行数: {cursor.rowcount}")

        # d. 提交事务
        # 因为连接时 autoCommit=False，所有更改需要手动提交
        conn.commit()
        print("事务已提交。")

        # e. 查询数据
        print("正在查询所有数据...")
        cursor.execute(f"SELECT id, name, create_time FROM {table_name} ORDER BY id")

        # 获取结果集描述 (手册 3.3.2.8)
        # 格式: (name, type_code, display_size, internal_size, precision, scale, null_ok)
        print(f"结果集列信息: {cursor.description}")

        # fetchall() 获取所有结果 (手册 3.3.1.10)
        all_rows = cursor.fetchall()
        print("查询结果 (fetchall):")
        for row in all_rows:
            print(row)

        # f. 更新数据
        print("正在更新 id=1 的数据...")
        cursor.execute(f"UPDATE {table_name} SET name = ? WHERE id = ?", ('张三丰', 1))
        print(f"更新操作影响行数: {cursor.rowcount}")
        conn.commit()

        # 再次查询以验证更新
        cursor.execute(f"SELECT name FROM {table_name} WHERE id = ?", (1,))
        # fetchone() 获取单行结果 (手册 3.3.1.8)
        updated_row = cursor.fetchone()
        print(f"更新后的名称: {updated_row[0]}")

        # g. 删除数据
        print("正在删除 id=4 的数据...")
        cursor.execute(f"DELETE FROM {table_name} WHERE id = ?", (4,))
        print(f"删除操作影响行数: {cursor.rowcount}")

        # h. 回滚事务
        # 假设我们不想提交这次删除
        conn.rollback()
        print("删除操作已回滚。")

        # 验证回滚
        cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        count = cursor.fetchone()[0]
        print(f"回滚后，表中剩余 {count} 条记录。")

        # i. 清理：删除演示表
        print("正在删除演示表...")
        cursor.execute(f"DROP TABLE {table_name}")
        conn.commit()
        print("基础操作演示完毕。")

# --- 3. 数据类型处理 ---
def demonstrate_data_types(conn):
    """
    演示如何处理各种常见的数据类型。
    """
    with conn.cursor() as cursor:
        print("\n--- 正在演示数据类型处理 ---")
        table_name = "PY_AI_TYPES"
        try:
            cursor.execute(f"""
                CREATE TABLE {table_name} (
                    c_int INT,
                    c_bigint BIGINT,
                    c_decimal DECIMAL(10, 2),
                    c_double DOUBLE,
                    c_varchar VARCHAR(200),
                    c_char CHAR(10),
                    c_date DATE,
                    c_timestamp TIMESTAMP,
                    c_clob CLOB,
                    c_blob BLOB
                )
            """)
        except dmPython.Error:
            print(f"表 {table_name} 已存在，将清空后继续。")
            cursor.execute(f"TRUNCATE TABLE {table_name}")

        # 准备数据
        sample_data = (
            12345,                                 # INT (dmPython.NUMBER)
            9876543210,                            # BIGINT (dmPython.BIGINT)
            Decimal('99.99'),                      # DECIMAL (dmPython.DECIMAL)
            123.456,                               # DOUBLE (dmPython.DOUBLE)
            "这是一个变长字符串",                    # VARCHAR (dmPython.STRING)
            "定长",                                # CHAR (dmPython.FIXED_STRING)
            date(2025, 9, 21),                     # DATE (dmPython.DATE)
            datetime(2025, 9, 21, 20, 14, 0),      # TIMESTAMP (dmPython.TIMESTAMP)
            "这是一段很长的文本数据，用于CLOB...",    # CLOB (dmPython.CLOB)
            b'\x01\x02\x03\x04\x05'                # BLOB (dmPython.BLOB)
        )

        # 插入数据
        sql = f"INSERT INTO {table_name} VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
        cursor.execute(sql, sample_data)
        conn.commit()
        print("各种数据类型已成功插入。")

        # 查询并验证
        cursor.execute(f"SELECT * FROM {table_name}")
        row = cursor.fetchone()
        print("查询到的数据类型如下:")
        print(f"  INT: {row[0]} (类型: {type(row[0])})")
        print(f"  BIGINT: {row[1]} (类型: {type(row[1])})")
        print(f"  DECIMAL: {row[2]} (类型: {type(row[2])})")
        print(f"  DOUBLE: {row[3]} (类型: {type(row[3])})")
        print(f"  VARCHAR: {row[4]} (类型: {type(row[4])})")
        print(f"  CHAR: '{row[5]}' (类型: {type(row[5])})") # 注意定长字符串可能带空格
        print(f"  DATE: {row[6]} (类型: {type(row[6])})")
        print(f"  TIMESTAMP: {row[7]} (类型: {type(row[7])})")
        print(f"  CLOB: {row[8]} (类型: {type(row[8])})")
        print(f"  BLOB: {row[9]} (类型: {type(row[9])})")

        # 清理
        cursor.execute(f"DROP TABLE {table_name}")
        conn.commit()
        print("数据类型处理演示完毕。")

# --- 4. 存储过程与函数 ---
def demonstrate_procedures(conn):
    """
    演示如何创建并调用存储过程和函数。
    """
    with conn.cursor() as cursor:
        print("\n--- 正在演示存储过程和函数 ---")

        # a. 创建一个存储过程 (带输入输出参数)
        proc_sql = """
        CREATE OR REPLACE PROCEDURE PY_GET_USER_INFO(
            p_id IN INT,
            p_name OUT VARCHAR,
            p_status OUT INT
        )
        AS
        BEGIN
            IF p_id = 1 THEN
                p_name := '管理员';
                p_status := 0;
            ELSE
                p_name := '未知用户';
                p_status := -1;
            END IF;
        END;
        """
        cursor.execute(proc_sql)
        print("存储过程 PY_GET_USER_INFO 已创建。")

        # b. 调用存储过程 (callproc) (手册 3.3.1.1)
        # 输出参数需要提供占位符变量
        user_id = 1
        out_name = ""
        out_status = 0
        params = (user_id, out_name, out_status)
        result = cursor.callproc("PY_GET_USER_INFO", params)
        print(f"调用存储过程输入ID={user_id}，返回结果: {result}")

        # c. 创建一个存储函数
        func_sql = """
        CREATE OR REPLACE FUNCTION PY_ADD(
            a INT,
            b INT
        )
        RETURN INT
        AS
        BEGIN
            RETURN a + b;
        END;
        """
        cursor.execute(func_sql)
        print("存储函数 PY_ADD 已创建。")

        # d. 调用存储函数 (callfunc) (手册 3.3.1.2)
        # 返回值是结果列表的第一个元素
        func_result = cursor.callfunc("PY_ADD", [10, 20])
        print(f"调用存储函数 PY_ADD(10, 20)，返回结果: {func_result[0]}")

        # 清理
        cursor.execute("DROP PROCEDURE PY_GET_USER_INFO")
        cursor.execute("DROP FUNCTION PY_ADD")
        conn.commit()
        print("存储过程和函数演示完毕。")

# --- 5. 错误处理 ---
def demonstrate_error_handling(conn):
    """
    演示如何捕获和处理 dmPython 的异常。
    """
    with conn.cursor() as cursor:
        print("\n--- 正在演示错误处理 ---")
        try:
            # 尝试执行一个错误的SQL语句
            cursor.execute("SELECT * FROM NON_EXISTENT_TABLE")
        except dmPython.Error as e:
            # 捕获 dmPython.Error 异常 (手册 3.1.1.32)
            print(f"成功捕获到预期的数据库错误: {e}")
            # 从连接对象获取最近的警告或错误信息 (手册 3.2.2.27)
            print(f"Connection.warning: {conn.warning}")

        print("错误处理演示完毕。")

# --- 6. SQLAlchemy 连接演示 ---
def demonstrate_sqlalchemy():
    """
    演示如何使用 SQLAlchemy 连接和操作达梦数据库。
    需要先安装 sqlalchemy 和 sqlalchemy_dm 包:
    pip install SQLAlchemy sqlalchemy_dm
    """
    if not create_engine:
        return # 如果导入失败，则不执行此演示

    print("\n--- 正在演示 SQLAlchemy 连接 ---")

    # a. 创建数据库引擎
    # 使用 dm+dmPython 方言 (注意 dmPython 的大小写)
    # connect_args 用于传递 dmPython.connect() 支持的参数
    try:
        # 修正：驱动名称 'dmPython' 的 'P' 必须大写，否则会导致 "Can't load plugin" 错误
        engine_url = f"dm+dmPython://{DM_USER}:{DM_PASSWORD}@{DM_SERVER}:{DM_PORT}/"
        engine = create_engine(
            engine_url,
            connect_args={'autoCommit': False, 'local_code': 1}, # 推荐关闭自动提交
            echo=False  # 设置为 True 可以打印执行的 SQL
        )
        print("SQLAlchemy 引擎创建成功。")
    except Exception as e:
        print(f"创建 SQLAlchemy 引擎失败: {e}")
        return

    # b. 连接并执行原生SQL
    table_name = "PY_AI_SQLALCHEMY_TEST"
    try:
        # 使用 with 语句管理连接资源
        with engine.connect() as connection:
            print("SQLAlchemy 连接成功。")

            # 验证连接。SQLAlchemy 2.0 的 "autobegin" 在这里会启动一个事务
            result = connection.execute(text("SELECT 1 FROM DUAL"))
            print(f"执行 'SELECT 1' 验证连接，结果: {result.scalar_one()}")
            connection.commit() # 必须显式提交由 "autobegin" 启动的事务

            # c. 执行 DDL 和 DML
            print(f"正在使用 SQLAlchemy 创建表: {table_name}...")
            
            # 使用一个事务块来完成清理、创建和插入
            with connection.begin() as trans:
                # 尝试删除旧表，忽略错误
                try:
                    connection.execute(text(f"DROP TABLE {table_name}"))
                    print(f"旧表 {table_name} 已删除。")
                except SQLAlchemyError:
                    pass # 表不存在是正常情况，忽略

                # 创建新表
                connection.execute(text(f"""
                    CREATE TABLE {table_name} (
                        id INT PRIMARY KEY,
                        description VARCHAR(200)
                    )
                """))
                print("表创建成功。")

                # 插入数据
                connection.execute(
                    text(f"INSERT INTO {table_name} (id, description) VALUES (:id, :desc)"),
                    [{"id": 1, "desc": "通过 SQLAlchemy 插入"}, {"id": 2, "desc": "另一条记录"}]
                )
                print("使用 SQLAlchemy 插入数据成功。")
                # 'with' 块结束时会自动提交事务
            print("SQLAlchemy 事务已提交。")

            # d. 查询数据
            print("正在使用 SQLAlchemy 查询数据...")
            select_result = connection.execute(text(f"SELECT * FROM {table_name} ORDER BY id"))
            for row in select_result.mappings(): # 使用 mappings() 可以像访问字典一样访问列
                print(f"  查询结果: id={row['id']}, description='{row['description']}'")

            # e. 清理
            print("正在清理 SQLAlchemy 演示表...")
            with connection.begin():
                connection.execute(text(f"DROP TABLE {table_name}"))
            print("SQLAlchemy 演示表已删除。")

    except SQLAlchemyError as e:
        print(f"SQLAlchemy 操作失败: {e}")
    finally:
        # 释放引擎资源
        if 'engine' in locals() and engine:
            engine.dispose()
            print("SQLAlchemy 引擎已释放。")

    print("SQLAlchemy 连接演示完毕。")


# --- 主执行函数 ---
def main():
    """
    主函数，按顺序执行所有演示。
    """
    # --- 原生 dmPython 演示 ---
    connection = get_connection()
    if connection:
        try:
            demonstrate_basic_operations(connection)
            demonstrate_data_types(connection)
            demonstrate_procedures(connection)
            demonstrate_error_handling(connection)
        except dmPython.Error as e:
            print(f"在原生 dmPython 演示过程中发生未捕获的错误: {e}")
        finally:
            connection.close()
            print("\n数据库连接已关闭。")
    else:
        print("\n由于原生 dmPython 连接失败，跳过相关演示。")

    # --- SQLAlchemy 演示 ---
    # 这个演示独立于上面的连接
    demonstrate_sqlalchemy()


if __name__ == "__main__":
    main()

## pip install dmPython
## pip install SQLAlchemy sqlalchemy_dm
