.. _architecture:

##########################
系统架构设计
##########################

本文档详细描述了 Qzen 项目的技术选型、系统架构和关键设计决策。

推荐技术栈
======================

.. list-table:: 技术栈详情
   :widths: 20 20 20 40
   :header-rows: 1

   * - 组件分类
     - 技术选型
     - 建议版本
     - 选型理由
   * - GUI框架
     - PyQt6
     - 6.5+
     - 功能强大、成熟稳定，通过 ``QThread`` 能完美解决UI响应性问题。
   * - 数据持久化/ORM
     - SQLAlchemy
     - 2.0+
     - 将业务逻辑与DM8数据库解耦，代码更清晰，易于维护。
   * - 中文分词
     - Jieba
     - 0.42+
     - 社区广泛使用，分词效果好，支持自定义词典和停用词，满足项目需求。
   * - 相似度计算
     - Scikit-learn
     - 1.3+
     - 提供工业级的TF-IDF和余弦相似度算法，满足“简约高效”的要求。
   * - 近邻搜索加速
     - Scikit-learn
     - 1.3+
     - 内置的 ``NearestNeighbors`` 类足以在5000个文档的规模下实现快速搜索。
   * - 应用打包
     - PyInstaller
     - 6.0+
     - 将项目打包为单个 ``.exe`` 文件，便于Windows用户分发和使用。
   * - 文档生成
     - Sphinx
     - 7.0+
     - 遵循DDAC工作流，实现代码与文档的同步。

graphviz_output_format = 'png'

graphviz_dot_args = [ '-Gcharset=utf8'  # <-- 强制 Graphviz 使用 UTF-8 编码处理文本 ]

系统架构
================

本项目采用 **三层分层架构 (3-Tier Architecture)**，将系统解耦为表现层、业务逻辑层和数据访问层。

.. graphviz::
   :align: center

   digraph Architecture {
      // --- 全局字体和编码设置 ---
      graph [fontname="Microsoft YaHei"];
      node  [fontname="Microsoft YaHei"];
      edge  [fontname="Microsoft YaHei"];

      // --- 布局和样式设置 ---
      rankdir=TB;
      node [shape=box, style=rounded];

      // --- 图形内容 ---
      subgraph cluster_ui {
         label = "表现层 (Presentation Layer)";
         ui [label="用户界面 (PyQt6)\n接收用户操作，展示部分结果"];
      }

      subgraph cluster_core {
         label = "业务逻辑层 (Business Logic Layer)";
         core [label="核心功能模块\n去重、相似度计算、聚类"];
      }

      subgraph cluster_data {
         label = "数据访问层 (Data Access Layer)";
         dal [label="数据访问接口 (SQLAlchemy, os)"];
      }

      subgraph cluster_datasource {
         label = "数据源 (Data Sources)";
         filesystem [label="文件系统"];
         database [label="DM8 数据库"];
      }

      ui -> core [label="调用功能接口 / 请求取消"];
      core -> ui [label="返回 (总结, 结果子集) / 状态"];
      core -> dal [label="请求/写入数据"];
      dal -> core [label="返回数据"];
      dal -> filesystem;
      dal -> database [label="读/写 全部结果与缓存"];
   }

* **表现层 (UI)**: 完全由 ``qzen_ui`` 包负责。它包含所有的窗口、控件和事件处理逻辑，并通过调用业务逻辑层的接口来响应用户交互。
* **业务逻辑层 (Core)**: 由 ``qzen_core`` 包负责。它实现了所有核心算法和业务规则，不依赖于任何UI或具体的数据库实现。
* **数据访问层 (DAL)**: 由 ``qzen_data`` 包负责。它抽象了所有对文件系统和DM8数据库的访问，为上层提供统一、简洁的数据操作接口。

关键设计决策
====================

1.  **UI响应性**: 所有耗时操作（文件扫描、数据库查询、相似度计算） **必须** 在后台线程 (``QThread``) 中执行。主UI线程仅负责更新界面和与用户交互，从而确保界面在处理大量文件时依然流畅。

2.  **协作式任务取消**: 为了在长时间运行的任务中给予用户控制权，我们实现了一个协作式的取消机制。用户可以随时请求中止正在进行的操作，而程序会安全、优雅地退出任务。

3.  **轻量级相似度算法**: 我们选择 **TF-IDF + 余弦相似度** 而非深度学习模型（如BERT）。这个决策基于以下考虑：
    * **性能**: 对于数千级别的文档，该方法计算速度快，资源消耗低，完全满足性能要求。
    * **简单性**: 算法成熟，易于实现和调试。
    * **效果**: 对于文档聚类和相似性排序任务，该方法已经能提供足够好的、可接受的近似结果。

4.  **数据库作为核心存储**: DM8数据库是系统的核心存储引擎，它扮演双重角色：
    * **缓存和索引**: 存储文档的哈希值、内容切片、特征向量等中间计算结果。下次运行时，程序会先检查数据库，避免重复计算，从而极大地加速了处理过程。
    * **结果持久化**: 存储所有操作的最终结果，如去重列表、重命名映射和搜索结果。这取代了之前将大量结果返回到内存的做法。

5.  **混合式结果处理策略**: 这是一个关键的架构决策，旨在同时满足大规模数据处理的健壮性和小规模数据下的即时用户反馈。

6.  **用户可配置的算法参数**: 为了在易用性和灵活性之间取得平衡，我们将部分核心算法的关键参数暴露给用户，允许高级用户根据其具体需求进行调优。

7.  **交互式结果呈现**: 为了将Qzen从一个分析工具转变为一个高效的整理工具，UI中显示的结果列表将不再是静态的。用户可以直接与结果进行交互。

8.  **面向接口而非实现编程**: 各层之间的交互应通过定义好的接口（例如，业务层的一个类和方法）进行。

9.  **中文文本预处理流程 (Chinese Text Preprocessing Pipeline)**: 为了从根本上提升相似度计算的准确性，我们必须在将文本送入 TF-IDF 向量化器之前，实施一个健壮的预处理流程。

10. **强制使用 UTF-8 数据库连接编码**: 为了从根本上避免在与数据库交互时出现 ``UnicodeEncodeError``，必须确保与数据库的连接层使用 `UTF-8` 编码。

11. **对大批量数据库操作实施分批处理 (Batch Processing)**: 为了提升处理超大规模文件集合时的健壮性，所有向数据库批量插入多条记录的操作都必须采用分批处理机制。

12. **对文件系统操作实施健壮的错误处理**: 为了避免因单个文件被其他程序锁定而导致整个任务失败，所有涉及文件系统写入或复制的操作都必须能够优雅地处理 ``PermissionError``。

13. **可动态更新的自定义停用词**: 为了解决特定领域（如公司、产品）的通用高频词污染分析结果的问题，我们引入一个由用户维护的、可运行时动态更新的全局停用词列表。

    * **问题根源**: 用户需要一种明确、可控的方式来管理其专属的停用词，并希望这些更改能立即对后续的分析任务生效，而无需重启程序或重新配置数据库。
    * **实现方式 (UI)**: 在 ``qzen_ui.main_window`` 的“配置”标签页中，为自定义停用词提供一个明确的交互模型：
        1. **只读状态 (默认)**: 文本框默认处于只读状态（灰色背景），清晰地展示当前已生效的停用词。旁边显示一个“编辑”按钮。
        2. **编辑状态**: 点击“编辑”后，文本框变为可编辑状态（白色背景），同时按钮切换为“保存并应用”。
        3. **保存与应用**: 点击“保存并应用”后，触发一个“热更新”流程，同时UI返回只读状态。

    * **实现方式 (热更新)**: 这是一个自顶向下的数据流，确保用户所做的更改能被即时应用：
        1. **UI层 (`main_window`)**: “保存并应用”按钮的点击事件，在将新列表存入 `config.json` 的同时，会调用业务逻辑层 ``Orchestrator`` 的一个新方法，如 `update_stopwords()`，并将新的词语列表作为参数传递。
        2. **业务逻辑层 (`orchestrator`)**: `update_stopwords()` 方法会继续将这个新列表传递给它所持有的 ``SimilarityEngine`` 实例。
        3. **核心引擎层 (`similarity_engine`)**: ``SimilarityEngine`` 接收到新列表后，会用它来更新其内部的停用词集合。由于分词器在每次被调用时都会引用这个集合，因此这一更新将自动对所有后续的文本分析任务生效。

14. **智能主题文件夹命名算法 (V2 - 安全实现)**: 为了提供更具可读性的整理结果，并从根本上解决旧算法存在的内存崩溃风险（``0xC0000409``），我们采用一个全新的、基于向量平均值的安全算法。

    * **问题根源**: 旧算法在循环中为每个文件簇拼接一个巨大的字符串，并反复创建新的 ``TfidfVectorizer`` 实例来处理它。当这个字符串过大时，会导致底层C/C++库发生栈缓冲区溢出，引发程序崩溃。
    * **新算法核心思想**: 新算法完全避免了在循环中创建新对象或处理大字符串。它利用已有的全局计算成果（完整的TF-IDF向量矩阵和词汇表），通过纯粹的、高效且内存安全的 ``numpy`` 矩阵运算来找到每个簇的主题词。
    * **实现方式**: 此算法在 ``qzen_core.orchestrator`` 的 ``run_topic_clustering`` 方法中实现。
        1. **预热引擎**: 确保所有文档的向量和全局词汇表已从数据库加载到内存中。
        2. **提取子矩阵**: 对于一个给定的文件簇（由一系列文档索引构成），从全局的 ``feature_matrix`` 中提取出对应的行，形成一个代表该簇的子矩阵。
        3. **计算平均主题向量**: 使用 ``numpy.mean`` 对该子矩阵按列求平均值（``axis=0``），得到一个代表该簇“平均主题”的单一向量。
        4. **提取核心主题词**: 对这个平均向量进行排序，找出值最高的 **1 到 5 个** 维度的索引。
        5. **映射到词语**: 使用这些索引，从全局的词汇表（通过 ``vectorizer.get_feature_names_out()`` 获取）中查出对应的主题词。
        6. **生成文件夹名**: 使用下划线 `_` 将提取出的主题词连接起来，形成最终的文件夹名。如果未能提取出任何有效的主题词，则使用一个后备名称，如 `相似文件簇_{i}`。
        7. **复制文件**: 将簇内的所有原始文件（保持原名）复制到这个新创建的主题文件夹下。
        8. **处理未归类文件**: 为了确保所有文件都被处理并支持多轮整理，所有在聚类过程中 **未被** 分配到任何主题簇的文件，将被统一复制到一个名为“未归类”的特殊文件夹中（位于目标文件夹下）。这为用户提供了一个清晰的工作区，可以方便地对这些文件进行第二轮或更低相似度阈值的聚类分析。
